
  android.accounts.AbstractAccountAuthenticator$Transport.addAccount(android.accounts.IAccountAuthenticatorResponse,java.lang.String,java.lang.String,[java.lang.String,android.os.Bundle)void   ::  [ android.permission.ACCOUNT_MANAGER ] 
  android.accounts.AbstractAccountAuthenticator$Transport.addAccountFromCredentials(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,android.os.Bundle)void   ::  [ android.permission.ACCOUNT_MANAGER ] 
  android.accounts.AbstractAccountAuthenticator$Transport.confirmCredentials(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,android.os.Bundle)void   ::  [ android.permission.ACCOUNT_MANAGER ] 
  android.accounts.AbstractAccountAuthenticator$Transport.editProperties(android.accounts.IAccountAuthenticatorResponse,java.lang.String)void   ::  [ android.permission.ACCOUNT_MANAGER ] 
  android.accounts.AbstractAccountAuthenticator$Transport.getAccountCredentialsForCloning(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account)void   ::  [ android.permission.ACCOUNT_MANAGER ] 
  android.accounts.AbstractAccountAuthenticator$Transport.getAccountRemovalAllowed(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account)void   ::  [ android.permission.ACCOUNT_MANAGER ] 
  android.accounts.AbstractAccountAuthenticator$Transport.getAuthToken(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,java.lang.String,android.os.Bundle)void   ::  [ android.permission.ACCOUNT_MANAGER ] 
  android.accounts.AbstractAccountAuthenticator$Transport.getAuthTokenLabel(android.accounts.IAccountAuthenticatorResponse,java.lang.String)void   ::  [ android.permission.ACCOUNT_MANAGER ] 
  android.accounts.AbstractAccountAuthenticator$Transport.hasFeatures(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,[java.lang.String)void   ::  [ android.permission.ACCOUNT_MANAGER ] 
  android.accounts.AbstractAccountAuthenticator$Transport.updateCredentials(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,java.lang.String,android.os.Bundle)void   ::  [ android.permission.ACCOUNT_MANAGER ] 
  android.hardware.location.ActivityRecognitionHardware.disableActivityEvent(java.lang.String,int)boolean   ::  [ android.permission.LOCATION_HARDWARE ] 
  android.hardware.location.ActivityRecognitionHardware.enableActivityEvent(java.lang.String,int,long)boolean   ::  [ android.permission.LOCATION_HARDWARE ] 
  android.hardware.location.ActivityRecognitionHardware.flush()boolean   ::  [ android.permission.LOCATION_HARDWARE ] 
  android.hardware.location.ActivityRecognitionHardware.getSupportedActivities()java.lang.String[]   ::  [ android.permission.LOCATION_HARDWARE ] 
  android.hardware.location.ActivityRecognitionHardware.isActivitySupported(java.lang.String)boolean   ::  [ android.permission.LOCATION_HARDWARE ] 
  android.hardware.location.ActivityRecognitionHardware.registerSink(android.hardware.location.IActivityRecognitionHardwareSink)boolean   ::  [ android.permission.LOCATION_HARDWARE ] 
  android.hardware.location.ActivityRecognitionHardware.unregisterSink(android.hardware.location.IActivityRecognitionHardwareSink)boolean   ::  [ android.permission.LOCATION_HARDWARE ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getCompleteVoiceMailNumber()java.lang.String   ::  [ android.permission.CALL_PRIVILEGED ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getDeviceId(java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getDeviceSvn(java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getGroupIdLevel1(java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getIccSerialNumber(java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getIccSimChallengeResponse(int,int,java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getIsimChallengeResponse(java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getIsimDomain()java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getIsimImpi()java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getIsimImpu()java.lang.String[]   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getIsimIst()java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getIsimPcscf()java.lang.String[]   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getLine1AlphaTag(java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getLine1Number(java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ]  OR  [ android.permission.READ_SMS ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getMsisdn(java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getSubscriberId(java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getVoiceMailAlphaTag(java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.internal.telephony.PhoneSubInfoProxy.getVoiceMailNumber(java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.addSubInfoRecord(java.lang.String,int)int   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.clearDefaultsForInactiveSubIds()void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.clearSubInfo()int   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.getActiveSubInfoCount(java.lang.String)int   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.getActiveSubscriptionInfo(int,java.lang.String)android.telephony.SubscriptionInfo   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.getActiveSubscriptionInfoForIccId(java.lang.String,java.lang.String)android.telephony.SubscriptionInfo   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.getActiveSubscriptionInfoForSimSlotIndex(int,java.lang.String)android.telephony.SubscriptionInfo   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.getActiveSubscriptionInfoList(java.lang.String)java.util.List   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.getAllSubInfoCount(java.lang.String)int   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.getAllSubInfoList(java.lang.String)java.util.List   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.getSubscriptionProperty(int,java.lang.String,java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.setDataRoaming(int,int)int   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.setDefaultDataSubId(int)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.setDefaultSmsSubId(int)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.setDefaultVoiceSubId(int)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.setDisplayName(java.lang.String,int)int   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.setDisplayNameUsingSrc(java.lang.String,int,long)int   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.setDisplayNumber(java.lang.String,int)int   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.setIconTint(int,int)int   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.internal.telephony.SubscriptionController.setSubscriptionProperty(int,java.lang.String,java.lang.String)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.nfc.NfcService$NfcAdapterService.addNfcUnlockHandler(android.nfc.INfcUnlockHandler,[int)void   ::  [ android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.nfc.NfcService$NfcAdapterService.disable(int,android.os.IBinder,java.lang.String)void   ::  [ android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.nfc.NfcService$NfcAdapterService.disableNdefPush()boolean   ::  [ android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.nfc.NfcService$NfcAdapterService.dispatch(android.nfc.Tag)void   ::  [ android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.nfc.NfcService$NfcAdapterService.enable()boolean   ::  [ android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.nfc.NfcService$NfcAdapterService.enableNdefPush()boolean   ::  [ android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.nfc.NfcService$NfcAdapterService.invokeBeam()void   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$NfcAdapterService.invokeBeamInternal(android.nfc.BeamShareData)void   ::  [ android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.nfc.NfcService$NfcAdapterService.pausePolling(int)void   ::  [ android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.nfc.NfcService$NfcAdapterService.resumePolling()void   ::  [ android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.nfc.NfcService$NfcAdapterService.setAppCallback(android.nfc.IAppCallback)void   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$NfcAdapterService.setForegroundDispatch(android.app.PendingIntent,[android.content.IntentFilter,android.nfc.TechListParcel)void   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$NfcAdapterService.setP2pModes(int,int)void   ::  [ android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.nfc.NfcService$NfcAdapterService.verifyNfcPermission()void   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$TagService.close(java.lang.String,java.lang.String)void   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$TagService.connect(int,int)int   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$TagService.formatNdef(int,[byte)int   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$TagService.getTechList(int)I[]   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$TagService.getTimeout(int)int   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$TagService.isNdef(int)boolean   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$TagService.ndefMakeReadOnly(int)int   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$TagService.ndefRead(int)android.nfc.NdefMessage   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$TagService.ndefWrite(int,android.nfc.NdefMessage)int   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$TagService.reconnect(int)int   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$TagService.rediscover(int)android.nfc.Tag   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$TagService.resetTimeouts()void   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$TagService.setTimeout(int,int)int   ::  [ android.permission.NFC ] 
  com.android.nfc.NfcService$TagService.transceive(int,[byte,boolean)android.nfc.TransceiveResult   ::  [ android.permission.NFC ] 
  com.android.nfc.cardemulation.CardEmulationManager$CardEmulationInterface.getAidGroupForService(int,android.content.ComponentName,java.lang.String)android.nfc.cardemulation.AidGroup   ::  [ android.permission.NFC ] 
  com.android.nfc.cardemulation.CardEmulationManager$CardEmulationInterface.getServices(int,java.lang.String)java.util.List   ::  [ android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.nfc.cardemulation.CardEmulationManager$CardEmulationInterface.isDefaultServiceForAid(int,android.content.ComponentName,java.lang.String)boolean   ::  [ android.permission.NFC ] 
  com.android.nfc.cardemulation.CardEmulationManager$CardEmulationInterface.isDefaultServiceForCategory(int,android.content.ComponentName,java.lang.String)boolean   ::  [ android.permission.NFC ] 
  com.android.nfc.cardemulation.CardEmulationManager$CardEmulationInterface.registerAidGroupForService(int,android.content.ComponentName,android.nfc.cardemulation.AidGroup)boolean   ::  [ android.permission.NFC ] 
  com.android.nfc.cardemulation.CardEmulationManager$CardEmulationInterface.removeAidGroupForService(int,android.content.ComponentName,java.lang.String)boolean   ::  [ android.permission.NFC ] 
  com.android.nfc.cardemulation.CardEmulationManager$CardEmulationInterface.setDefaultForNextTap(int,android.content.ComponentName)boolean   ::  [ android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.nfc.cardemulation.CardEmulationManager$CardEmulationInterface.setDefaultServiceForCategory(int,android.content.ComponentName,java.lang.String)boolean   ::  [ android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.nfc.cardemulation.CardEmulationManager$CardEmulationInterface.setPreferredService(android.content.ComponentName)boolean   ::  [ android.permission.NFC ] 
  com.android.nfc.cardemulation.CardEmulationManager$CardEmulationInterface.unsetPreferredService()boolean   ::  [ android.permission.NFC ] 
  com.android.phone.CarrierConfigLoader.getConfigForSubId(int)android.os.PersistableBundle   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ] 
  com.android.phone.CarrierConfigLoader.updateConfigForPhoneId(int,java.lang.String)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.answerRingingCall()void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.answerRingingCallForSubscriber(int)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.call(java.lang.String,java.lang.String)void   ::  [ android.permission.CALL_PHONE ] 
  com.android.phone.PhoneInterfaceManager.canChangeDtmfToneLength()boolean   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.disableDataConnectivity()boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.disableLocationUpdates()void   ::  [ android.permission.CONTROL_LOCATION_UPDATES ] 
  com.android.phone.PhoneInterfaceManager.disableLocationUpdatesForSubscriber(int)void   ::  [ android.permission.CONTROL_LOCATION_UPDATES ] 
  com.android.phone.PhoneInterfaceManager.enableDataConnectivity()boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.enableLocationUpdates()void   ::  [ android.permission.CONTROL_LOCATION_UPDATES ] 
  com.android.phone.PhoneInterfaceManager.enableLocationUpdatesForSubscriber(int)void   ::  [ android.permission.CONTROL_LOCATION_UPDATES ] 
  com.android.phone.PhoneInterfaceManager.enableVideoCalling(boolean)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.endCall()boolean   ::  [ android.permission.CALL_PHONE ] 
  com.android.phone.PhoneInterfaceManager.endCallForSubscriber(int)boolean   ::  [ android.permission.CALL_PHONE ] 
  com.android.phone.PhoneInterfaceManager.factoryReset(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL AND android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getAllCellInfo(java.lang.String)java.util.List   ::  [ android.permission.ACCESS_COARSE_LOCATION AND Binder.getCallingUid()=Process.myUid() ]  OR  [ android.permission.ACCESS_COARSE_LOCATION AND UserHandle.getCallingUserId()=ActivityManager.getCurrentUser() ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND UserHandle.getCallingUserId()=ActivityManager.getCurrentUser() ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND Binder.getCallingUid()=Process.myUid() ] 
  com.android.phone.PhoneInterfaceManager.getCalculatedPreferredNetworkType(java.lang.String)int   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getCdmaEriIconIndex(java.lang.String)int   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getCdmaEriIconIndexForSubscriber(int,java.lang.String)int   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getCdmaEriIconMode(java.lang.String)int   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getCdmaEriIconModeForSubscriber(int,java.lang.String)int   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getCdmaEriText(java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getCdmaEriTextForSubscriber(int,java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getCdmaMdn(int)java.lang.String   ::  [ android.permission.MODIFY_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getCdmaMin(int)java.lang.String   ::  [ android.permission.MODIFY_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getCellLocation(java.lang.String)android.os.Bundle   ::  [ android.permission.ACCESS_COARSE_LOCATION AND Binder.getCallingUid()=Process.myUid() ]  OR  [ android.permission.ACCESS_COARSE_LOCATION AND UserHandle.getCallingUser()=ActivityManager.getCurrentUser() ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND UserHandle.getCallingUser()=ActivityManager.getCurrentUser() ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND Binder.getCallingUid()=Process.myUid() ] 
  com.android.phone.PhoneInterfaceManager.getCellNetworkScanResults(int)com.android.internal.telephony.CellNetworkScanResult   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getDataEnabled(int)boolean   ::  [ android.permission.ACCESS_NETWORK_STATE ]  OR  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getDataNetworkType(java.lang.String)int   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getDataNetworkTypeForSubscriber(int,java.lang.String)int   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getDeviceId(java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getLine1AlphaTagForDisplay(int,java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getLine1NumberForDisplay(int,java.lang.String)java.lang.String   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getLteOnCdmaMode(java.lang.String)int   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getLteOnCdmaModeForSubscriber(int,java.lang.String)int   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getMergedSubscriberIds(java.lang.String)java.lang.String[]   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getNeighboringCellInfo(java.lang.String)java.util.List   ::  [ android.permission.ACCESS_COARSE_LOCATION AND Binder.getCallingUid()=Process.myUid() ]  OR  [ android.permission.ACCESS_COARSE_LOCATION AND UserHandle.getCallingUser()=ActivityManager.getCurrentUser() ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND UserHandle.getCallingUser()=ActivityManager.getCurrentUser() ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND Binder.getCallingUid()=Process.myUid() ] 
  com.android.phone.PhoneInterfaceManager.getNetworkTypeForSubscriber(int,java.lang.String)int   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getPcscfAddress(java.lang.String,java.lang.String)java.lang.String[]   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getPreferredNetworkType(int)int   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getRadioAccessFamily(int,java.lang.String)int   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getTetherApnRequired()int   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.getVoiceNetworkTypeForSubscriber(int,java.lang.String)int   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.handlePinMmi(java.lang.String)boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.handlePinMmiForSubscriber(int,java.lang.String)boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.iccCloseLogicalChannel(int)boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.iccExchangeSimIO(int,int,int,int,int,java.lang.String)B[]   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.iccOpenLogicalChannel(java.lang.String)android.telephony.IccOpenLogicalChannelResponse   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.iccTransmitApduBasicChannel(int,int,int,int,int,java.lang.String)java.lang.String   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.iccTransmitApduLogicalChannel(int,int,int,int,int,int,java.lang.String)java.lang.String   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.invokeOemRilRequestRaw([byte,[byte)int   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.isIdle(java.lang.String)boolean   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.isIdleForSubscriber(int,java.lang.String)boolean   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.isOffhook(java.lang.String)boolean   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.isOffhookForSubscriber(int,java.lang.String)boolean   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.isRadioOn(java.lang.String)boolean   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.isRadioOnForSubscriber(int,java.lang.String)boolean   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.isRinging(java.lang.String)boolean   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.isRingingForSubscriber(int,java.lang.String)boolean   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.isSimPinEnabled(java.lang.String)boolean   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.isVideoCallingEnabled(java.lang.String)boolean   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ]  OR  [ android.permission.READ_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.isWorldPhone()boolean   ::  [ android.permission.READ_PRIVILEGED_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.nvReadItem(int)java.lang.String   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.nvResetConfig(int)boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.nvWriteCdmaPrl([byte)boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.nvWriteItem(int,java.lang.String)boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.sendEnvelopeWithStatus(java.lang.String)java.lang.String   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.setDataEnabled(int,boolean)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.setImsRegistrationState(boolean)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.setNetworkSelectionModeAutomatic(int)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.setNetworkSelectionModeManual(int,com.android.internal.telephony.OperatorInfo,boolean)boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.setPreferredNetworkType(int,int)boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.setRadio(boolean)boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.setRadioForSubscriber(int,boolean)boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.setRadioPower(boolean)boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.shutdownMobileRadios()void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.supplyPin(java.lang.String)boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.supplyPinForSubscriber(int,java.lang.String)boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.supplyPinReportResult(java.lang.String)I[]   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.supplyPinReportResultForSubscriber(int,java.lang.String)I[]   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.supplyPuk(java.lang.String,java.lang.String)boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.supplyPukForSubscriber(int,java.lang.String,java.lang.String)boolean   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.supplyPukReportResult(java.lang.String,java.lang.String)I[]   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.supplyPukReportResultForSubscriber(int,java.lang.String,java.lang.String)I[]   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.toggleRadioOnOff()void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.phone.PhoneInterfaceManager.toggleRadioOnOffForSubscriber(int)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.AppOpsService.checkAudioOperation(int,int,int,java.lang.String)int   ::  [ android.permission.UPDATE_APP_OPS_STATS ]  OR  [ x3=Binder.getCallingUid() ]  OR  [ Binder.getCallingPid()=Process.myPid() ] 
  com.android.server.AppOpsService.checkOperation(int,int,java.lang.String)int   ::  [ android.permission.UPDATE_APP_OPS_STATS ]  OR  [ x2=Binder.getCallingUid() ]  OR  [ Binder.getCallingPid()=Process.myPid() ] 
  com.android.server.AppOpsService.finishOperation(android.os.IBinder,int,int,java.lang.String)void   ::  [ android.permission.UPDATE_APP_OPS_STATS ]  OR  [ x2=Binder.getCallingUid() ]  OR  [ Binder.getCallingPid()=Process.myPid() ] 
  com.android.server.AppOpsService.getOpsForPackage(int,java.lang.String,[int)java.util.List   ::  [ android.permission.GET_APP_OPS_STATS ] 
  com.android.server.AppOpsService.getPackagesForOps([int)java.util.List   ::  [ android.permission.GET_APP_OPS_STATS ] 
  com.android.server.AppOpsService.noteOperation(int,int,java.lang.String)int   ::  [ android.permission.UPDATE_APP_OPS_STATS ]  OR  [ x2=Binder.getCallingUid() ]  OR  [ Binder.getCallingPid()=Process.myPid() ] 
  com.android.server.AppOpsService.resetAllModes(int,java.lang.String)void   ::  [ android.permission.UPDATE_APP_OPS_STATS ] 
  com.android.server.AppOpsService.setAudioRestriction(int,int,int,int,[java.lang.String)void   ::  [ android.permission.UPDATE_APP_OPS_STATS ]  OR  [ x3=Binder.getCallingUid() ]  OR  [ Binder.getCallingPid()=Process.myPid() ] 
  com.android.server.AppOpsService.setMode(int,android.os.IBinder,java.lang.String)void   ::  [ android.permission.UPDATE_APP_OPS_STATS ]  OR  [ Binder.getCallingPid()=Process.myPid() ] 
  com.android.server.AppOpsService.setUidMode(int,int,int)void   ::  [ android.permission.UPDATE_APP_OPS_STATS ]  OR  [ Binder.getCallingPid()=Process.myPid() ] 
  com.android.server.AppOpsService.startOperation(android.os.IBinder,int,int,java.lang.String)int   ::  [ android.permission.UPDATE_APP_OPS_STATS ]  OR  [ x3=Binder.getCallingUid() ]  OR  [ Binder.getCallingPid()=Process.myPid() ] 
  com.android.server.BluetoothManagerService.disable(int,android.os.IBinder,java.lang.String)void   ::  [ android.permission.BLUETOOTH_ADMIN AND Binder.getCallingUid()=1027 ]  OR  [ android.permission.BLUETOOTH_ADMIN AND Binder.getCallingUid()=getPackageManager().getPackageUid($com.android.systemui$) ]  OR  [ android.permission.BLUETOOTH_ADMIN AND Binder.getCallingUid()=1000 ]  OR  [ android.permission.BLUETOOTH_ADMIN AND ActivityManager.getCurrentUser()=UserHandle.getCallingUserId() ] 
  com.android.server.BluetoothManagerService.enable()boolean   ::  [ android.permission.BLUETOOTH_ADMIN AND Binder.getCallingUid()=1027 ]  OR  [ android.permission.BLUETOOTH_ADMIN AND Binder.getCallingUid()=getPackageManager().getPackageUid($com.android.systemui$) ]  OR  [ android.permission.BLUETOOTH_ADMIN AND Binder.getCallingUid()=1000 ]  OR  [ android.permission.BLUETOOTH_ADMIN AND ActivityManager.getCurrentUser()=UserHandle.getCallingUserId() ] 
  com.android.server.BluetoothManagerService.enableNoAutoConnect()boolean   ::  [ android.permission.BLUETOOTH_ADMIN AND UserHandle.getAppId(Binde.getCallingUid())=1027 ] 
  com.android.server.BluetoothManagerService.getAddress()java.lang.String   ::  [ android.permission.BLUETOOTH: AND Binder.getCallingUid()=1027 AND android.permission.LOCAL_MAC_ADDRESS ]  OR  [ android.permission.BLUETOOTH: AND ActivityManager.getCurrentUser()=UserHandle.getCallingUserId() AND android.permission.LOCAL_MAC_ADDRESS ]  OR  [ android.permission.BLUETOOTH: AND Binder.getCallingUid()=getPackageManager().getPackageUid($com.android.systemui$) AND android.permission.LOCAL_MAC_ADDRESS ]  OR  [ android.permission.BLUETOOTH AND Binder.getCallingUid()=1000 AND android.permission.LOCAL_MAC_ADDRESS ] 
  com.android.server.BluetoothManagerService.registerStateChangeCallback(android.bluetooth.IBluetoothStateChangeCallback)void   ::  [ android.permission.BLUETOOTH ] 
  com.android.server.BluetoothManagerService.unregisterAdapter(android.bluetooth.IBluetoothManagerCallback)void   ::  [ android.permission.BLUETOOTH ] 
  com.android.server.BluetoothManagerService.unregisterStateChangeCallback(android.bluetooth.IBluetoothStateChangeCallback)void   ::  [ android.permission.BLUETOOTH ] 
  com.android.internal.telephony.UiccSmsController.copyMessageToIccEfForSubscriber(int,java.lang.String,int,[byte,[byte)boolean   ::  [ android.permission.RECEIVE_SMS AND android.permission.SEND_SMS ] 
  com.android.internal.telephony.UiccSmsController.disableCellBroadcastForSubscriber(int,int,int)boolean   ::  [ android.permission.RECEIVE_SMS ] 
  com.android.internal.telephony.UiccSmsController.disableCellBroadcastRangeForSubscriber(int,int,int,int)boolean   ::  [ android.permission.RECEIVE_SMS ] 
  com.android.internal.telephony.UiccSmsController.enableCellBroadcastForSubscriber(int,int,int)boolean   ::  [ android.permission.RECEIVE_SMS ] 
  com.android.internal.telephony.UiccSmsController.enableCellBroadcastRangeForSubscriber(int,int,int,int)boolean   ::  [ android.permission.RECEIVE_SMS ] 
  com.android.internal.telephony.UiccSmsController.getAllMessagesFromIccEfForSubscriber(int,java.lang.String)java.util.List   ::  [ android.permission.RECEIVE_SMS ] 
  com.android.internal.telephony.UiccSmsController.injectSmsPduForSubscriber(int,[byte,java.lang.String,android.app.PendingIntent)void   ::  [ android.permission.RECEIVE_SMS ] 
  com.android.internal.telephony.UiccSmsController.sendDataForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,int,[byte,android.app.PendingIntent,android.app.PendingIntent)void   ::  [ android.permission.SEND_SMS: ]  OR  [ android.permission.SEND_SMS: AND android.permission.SEND_RESPOND_VIA_MESSAGE: ] 
  com.android.internal.telephony.UiccSmsController.sendDataForSubscriberWithSelfPermissions(int,java.lang.String,java.lang.String,java.lang.String,int,[byte,android.app.PendingIntent,android.app.PendingIntent)void   ::  [ android.permission.SEND_SMS: ]  OR  [ android.permission.SEND_SMS: AND android.permission.SEND_RESPOND_VIA_MESSAGE: ] 
  com.android.internal.telephony.UiccSmsController.sendMultipartTextForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.util.List,java.util.List,java.util.List,boolean)void   ::  [ android.permission.SEND_SMS: ]  OR  [ android.permission.SEND_SMS: AND android.permission.SEND_RESPOND_VIA_MESSAGE: ] 
  com.android.internal.telephony.UiccSmsController.sendStoredMultipartText(int,java.lang.String,android.net.Uri,java.lang.String,java.util.List,java.util.List)void   ::  [ android.permission.SEND_SMS: ]  OR  [ android.permission.SEND_SMS: AND android.permission.SEND_RESPOND_VIA_MESSAGE: ] 
  com.android.internal.telephony.UiccSmsController.sendStoredText(int,java.lang.String,android.net.Uri,java.lang.String,android.app.PendingIntent,android.app.PendingIntent)void   ::  [ android.permission.SEND_SMS: ]  OR  [ android.permission.SEND_SMS: AND android.permission.SEND_RESPOND_VIA_MESSAGE: ] 
  com.android.internal.telephony.UiccSmsController.sendTextForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.app.PendingIntent,android.app.PendingIntent,boolean)void   ::  [ android.permission.SEND_SMS: ]  OR  [ android.permission.SEND_SMS: AND android.permission.SEND_RESPOND_VIA_MESSAGE: ] 
  com.android.internal.telephony.UiccSmsController.sendTextForSubscriberWithSelfPermissions(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.app.PendingIntent,android.app.PendingIntent)void   ::  [ android.permission.SEND_SMS: ]  OR  [ android.permission.SEND_SMS: AND android.permission.SEND_RESPOND_VIA_MESSAGE: ] 
  com.android.internal.telephony.UiccSmsController.updateMessageOnIccEfForSubscriber(int,java.lang.String,int,int,[byte)boolean   ::  [ android.permission.RECEIVE_SMS: AND android.permission.SEND_SMS: ] 
  com.android.server.ConnectivityService.factoryReset(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL AND android.permission.WRITE_SETTINGS AND android.permission.CONTROL_VPN: ]  OR  [ android.permission.CONNECTIVITY_INTERNAL AND android.permission.CHANGE_NETWORK_STATE AND android.permission.CONTROL_VPN: ] 
  com.android.server.ConnectivityService.getActiveLinkProperties()android.net.LinkProperties   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getActiveNetwork()android.net.Network   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getActiveNetworkInfo()android.net.NetworkInfo   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getActiveNetworkInfoForUid(int)android.net.NetworkInfo   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.ConnectivityService.getActiveNetworkQuotaInfo()android.net.NetworkQuotaInfo   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getAllNetworkInfo()android.net.NetworkInfo[]   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getAllNetworkState()android.net.NetworkState[]   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getAllNetworks()android.net.Network[]   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getAllVpnInfo()com.android.internal.net.VpnInfo[]   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.ConnectivityService.getDefaultNetworkCapabilitiesForUser(int)android.net.NetworkCapabilities[]   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getLastTetherError(java.lang.String)int   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getLegacyVpnInfo(int)com.android.internal.net.LegacyVpnInfo   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL AND android.permission.CONTROL_VPN: ]  OR  [ UserHandle.getCallingUserId()=x1 AND android.permission.CONTROL_VPN: ] 
  com.android.server.ConnectivityService.getLinkProperties(android.net.Network)android.net.LinkProperties   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getLinkPropertiesForType(int)android.net.LinkProperties   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getMobileProvisioningUrl()java.lang.String   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.ConnectivityService.getNetworkCapabilities(android.net.Network)android.net.NetworkCapabilities   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getNetworkForType(int)android.net.Network   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getNetworkInfo(int)android.net.NetworkInfo   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getNetworkInfoForNetwork(android.net.Network)android.net.NetworkInfo   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getTetherableBluetoothRegexs()java.lang.String[]   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getTetherableIfaces()java.lang.String[]   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getTetherableUsbRegexs()java.lang.String[]   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getTetherableWifiRegexs()java.lang.String[]   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getTetheredDhcpRanges()java.lang.String[]   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.ConnectivityService.getTetheredIfaces()java.lang.String[]   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getTetheringErroredIfaces()java.lang.String[]   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.getVpnConfig(int)com.android.internal.net.VpnConfig   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL AND android.permission.CONTROL_VPN: ]  OR  [ UserHandle.getCallingUserId()=x1 AND android.permission.CONTROL_VPN: ] 
  com.android.server.ConnectivityService.isActiveNetworkMetered()boolean   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.isNetworkSupported(int)boolean   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.isTetheringSupported()boolean   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.listenForNetwork(android.net.NetworkCapabilities,android.os.Messenger,android.os.IBinder)android.net.NetworkRequest   ::  [ android.permission.ACCESS_NETWORK_STATE: ]  OR  [ android.permission.ACCESS_WIFI_STATE ] 
  com.android.server.ConnectivityService.pendingListenForNetwork(android.net.NetworkCapabilities,android.app.PendingIntent)void   ::  [ android.permission.ACCESS_NETWORK_STATE: ]  OR  [ android.permission.ACCESS_WIFI_STATE ] 
  com.android.server.ConnectivityService.pendingRequestForNetwork(android.net.NetworkCapabilities,android.app.PendingIntent)android.net.NetworkRequest   ::  [ android.permission.CHANGE_NETWORK_STATE ]  OR  [ android.permission.WRITE_SETTINGS ]  OR  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.ConnectivityService.prepareVpn(java.lang.String,java.lang.String,int)boolean   ::  [ UserHandle.getCallingUserId()=x3 AND android.permission.CONTROL_VPN: ]  OR  [ android.permission.INTERACT_ACROSS_USERS_FULL AND android.permission.CONTROL_VPN: ] 
  com.android.server.ConnectivityService.registerNetworkAgent(android.os.Messenger,android.net.NetworkInfo,android.net.LinkProperties,android.net.NetworkCapabilities,int,android.net.NetworkMisc)int   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.ConnectivityService.registerNetworkFactory(android.os.Messenger,java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.ConnectivityService.reportInetCondition(int,int)void   ::  [ android.permission.ACCESS_NETWORK_STATE: AND android.permission.INTERNET ] 
  com.android.server.ConnectivityService.reportNetworkConnectivity(android.net.Network,boolean)void   ::  [ android.permission.ACCESS_NETWORK_STATE: AND android.permission.INTERNET ] 
  com.android.server.ConnectivityService.requestBandwidthUpdate(android.net.Network)boolean   ::  [ android.permission.ACCESS_NETWORK_STATE ] 
  com.android.server.ConnectivityService.requestNetwork(android.net.NetworkCapabilities,android.os.Messenger,int,android.os.IBinder,int)android.net.NetworkRequest   ::  [ android.permission.CHANGE_NETWORK_STATE ]  OR  [ android.permission.WRITE_SETTINGS ]  OR  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.ConnectivityService.requestRouteToHostAddress(int,[byte)boolean   ::  [ android.permission.WRITE_SETTINGS AND android.permission.CONNECTIVITY_INTERNAL AND mProtectedNetworks.contains(x1) ]  OR  [ android.permission.WRITE_SETTINGS AND !(mProtectedNetworks.contains(x1)) ]  OR  [ android.permission.CHANGE_NETWORK_STATE AND android.permission.CONNECTIVITY_INTERNAL AND mProtectedNetworks.contains(x1) ]  OR  [ android.permission.CHANGE_NETWORK_STATE AND !(mProtectedNetworks.contains(x1)) ] 
  com.android.server.ConnectivityService.setAcceptUnvalidated(android.net.Network,boolean,boolean)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.ConnectivityService.setAirplaneMode(boolean)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.ConnectivityService.setGlobalProxy(android.content.ComponentName,java.lang.String,java.lang.String)android.content.ComponentName   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.ConnectivityService.setProvisioningNotificationVisible(boolean,int,java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.ConnectivityService.setUsbTethering(boolean)int   ::  [ android.permission.CHANGE_NETWORK_STATE ]  OR  [ android.permission.WRITE_SETTINGS ]  OR  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.ConnectivityService.setUsbTethering(boolean)int   ::  [ android.permission.CHANGE_NETWORK_STATE AND android.permission.ACCESS_NETWORK_STATE AND android.permission.TETHER_PRIVILEGED ]  OR  [ android.permission.CONNECTIVITY_INTERNAL AND android.permission.ACCESS_NETWORK_STATE AND android.permission.TETHER_PRIVILEGED ]  OR  [ android.permission.WRITE_SETTINGS AND android.permission.ACCESS_NETWORK_STATE AND android.permission.TETHER_PRIVILEGED ] 
  com.android.server.ConnectivityService.setVpnPackageAuthorization(java.lang.String,int,boolean)void   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL AND android.permission.CONTROL_VPN: ]  OR  [ UserHandle.getCallingUserId()=x2 AND android.permission.CONTROL_VPN: ] 
  com.android.server.ConnectivityService.startLegacyVpn(com.android.internal.net.VpnProfile)void   ::  [ android.permission.ACCESS_NETWORK_STATE: AND android.permission.CONTROL_VPN ] 
  com.android.server.ConnectivityService.startNattKeepalive(android.net.Network,int,android.os.Messenger,android.os.IBinder,java.lang.String,int,java.lang.String)void   ::  [ android.permission.PACKET_KEEPALIVE_OFFLOAD ] 
  com.android.server.ConnectivityService.tether(java.lang.String)int   ::  [ android.permission.CHANGE_NETWORK_STATE AND android.permission.TETHER_PRIVILEGED ]  OR  [ android.permission.WRITE_SETTINGS AND android.permission.TETHER_PRIVILEGED ]  OR  [ android.permission.CONNECTIVITY_INTERNAL AND android.permission.TETHER_PRIVILEGED ] 
  com.android.server.ConnectivityService.unregisterNetworkFactory(android.os.Messenger)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.ConnectivityService.untether(java.lang.String)int   ::  [ android.permission.CHANGE_NETWORK_STATE AND android.permission.TETHER_PRIVILEGED ]  OR  [ android.permission.WRITE_SETTINGS AND android.permission.TETHER_PRIVILEGED ]  OR  [ android.permission.CONNECTIVITY_INTERNAL AND android.permission.TETHER_PRIVILEGED ] 
  com.android.server.ConnectivityService.updateLockdownVpn()boolean   ::  [ Binder.getCallingUid()=1000 ] 
  com.android.server.ConsumerIrService.getCarrierFrequencies()I[]   :: 
  com.android.server.ConsumerIrService.transmit(java.lang.String,int,[int)void   :: 
  com.android.server.DeviceIdleController$BinderService.addPowerSaveTempWhitelistApp(java.lang.String,long,int,java.lang.String)void   :: 
  com.android.server.DeviceIdleController$BinderService.addPowerSaveTempWhitelistAppForMms(java.lang.String,int,java.lang.String)long   :: 
  com.android.server.DeviceIdleController$BinderService.addPowerSaveTempWhitelistAppForSms(java.lang.String,int,java.lang.String)long   :: 
  com.android.server.DeviceIdleController$BinderService.addPowerSaveWhitelistApp(java.lang.String)void   :: 
  com.android.server.DeviceIdleController$BinderService.exitIdle(java.lang.String)void   :: 
  com.android.server.DeviceIdleController$BinderService.removePowerSaveWhitelistApp(java.lang.String)void   :: 
  com.android.server.DropBoxManagerService.getNextEntry(java.lang.String,long)android.os.DropBoxManager$Entry   :: 
  com.android.server.InputMethodManagerService.addClient(com.android.internal.view.IInputMethodClient,com.android.internal.view.IInputContext,int,int)void   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.getCurrentInputMethodSubtype()android.view.inputmethod.InputMethodSubtype   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.getEnabledInputMethodList()java.util.List   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.getEnabledInputMethodSubtypeList(java.lang.String,boolean)java.util.List   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.getInputMethodList()java.util.List   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.getLastInputMethodSubtype()android.view.inputmethod.InputMethodSubtype   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.hideMySoftInput(android.os.IBinder,int)void   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.hideSoftInput(com.android.internal.view.IInputMethodClient,int,android.os.ResultReceiver)boolean   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.notifySuggestionPicked(android.text.style.SuggestionSpan,java.lang.String,int)boolean   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.registerSuggestionSpansForNotification([android.text.style.SuggestionSpan)void   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.removeClient(com.android.internal.view.IInputMethodClient)void   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.setAdditionalInputMethodSubtypes(java.lang.String,[android.view.inputmethod.InputMethodSubtype)void   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.setCurrentInputMethodSubtype(android.view.inputmethod.InputMethodSubtype)boolean   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.setImeWindowStatus(android.os.IBinder,int,int,boolean)void   ::  [ android.permission.STATUS_BAR ] 
  com.android.server.InputMethodManagerService.setInputMethod(android.os.IBinder,java.lang.String)void   ::  [ Binder.getCallingUid()=1000 AND android.permission.WRITE_SECURE_SETTINGS ]  OR  [ android.permission.INTERACT_ACROSS_USERS_FULL AND android.permission.WRITE_SECURE_SETTINGS ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) AND android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.server.InputMethodManagerService.setInputMethodAndSubtype(android.os.IBinder,java.lang.String,android.view.inputmethod.InputMethodSubtype)void   ::  [ Binder.getCallingUid()=1000 AND android.permission.WRITE_SECURE_SETTINGS ]  OR  [ android.permission.INTERACT_ACROSS_USERS_FULL AND android.permission.WRITE_SECURE_SETTINGS ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) AND android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.server.InputMethodManagerService.setInputMethodEnabled(java.lang.String,boolean)boolean   ::  [ Binder.getCallingUid()=1000 AND android.permission.WRITE_SECURE_SETTINGS ]  OR  [ android.permission.INTERACT_ACROSS_USERS_FULL AND android.permission.WRITE_SECURE_SETTINGS ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) AND android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.server.InputMethodManagerService.shouldOfferSwitchingToNextInputMethod(android.os.IBinder)boolean   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.showInputMethodAndSubtypeEnablerFromClient(com.android.internal.view.IInputMethodClient,java.lang.String)void   ::  [ Binder.getCallingUid()=1000 AND android.permission.STATUS_BAR ]  OR  [ android.permission.INTERACT_ACROSS_USERS_FULL AND android.permission.STATUS_BAR ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) AND android.permission.STATUS_BAR ] 
  com.android.server.InputMethodManagerService.showInputMethodPickerFromClient(com.android.internal.view.IInputMethodClient,int)void   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.showMySoftInput(android.os.IBinder,int)void   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.showSoftInput(com.android.internal.view.IInputMethodClient,int,android.os.ResultReceiver)boolean   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.InputMethodManagerService.startInput(com.android.internal.view.IInputMethodClient,com.android.internal.view.IInputContext,android.view.inputmethod.EditorInfo,int)com.android.internal.view.InputBindResult   ::  [ Binder.getCallingUid()=1000 AND android.permission.STATUS_BAR ]  OR  [ android.permission.INTERACT_ACROSS_USERS_FULL AND android.permission.STATUS_BAR ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) AND android.permission.STATUS_BAR ] 
  com.android.server.InputMethodManagerService.switchToLastInputMethod(android.os.IBinder)boolean   ::  [ Binder.getCallingUid()=1000 AND android.permission.WRITE_SECURE_SETTINGS ]  OR  [ android.permission.INTERACT_ACROSS_USERS_FULL AND android.permission.WRITE_SECURE_SETTINGS ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) AND android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.server.InputMethodManagerService.switchToNextInputMethod(android.os.IBinder,boolean)boolean   ::  [ Binder.getCallingUid()=1000 AND android.permission.WRITE_SECURE_SETTINGS ]  OR  [ android.permission.INTERACT_ACROSS_USERS_FULL AND android.permission.WRITE_SECURE_SETTINGS ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) AND android.permission.WRITE_SECURE_SETTINGS ] 
  com.android.server.InputMethodManagerService.updateStatusIcon(android.os.IBinder,java.lang.String,int)void   ::  [ Binder.getCallingUid()=1000 AND android.permission.STATUS_BAR ]  OR  [ android.permission.INTERACT_ACROSS_USERS_FULL AND android.permission.STATUS_BAR ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) AND android.permission.STATUS_BAR ] 
  com.android.server.InputMethodManagerService.windowGainedFocus(com.android.internal.view.IInputMethodClient,android.os.IBinder,int,int,int,android.view.inputmethod.EditorInfo,com.android.internal.view.IInputContext)com.android.internal.view.InputBindResult   ::  [ android.permission.ACCESS_FINE_LOCATION ]  OR  [ Binder.getCallingUid()=1000 AND android.permission.STATUS_BAR ]  OR  [ android.permission.INTERACT_ACROSS_USERS_FULL AND android.permission.STATUS_BAR ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND else ]  OR  [ android.permission.ACCESS_COARSE_LOCATION ]  OR  [ mSettings.isCurrentProfile(UserHandle.getUserId(Binder.getCallingUid())) AND android.permission.STATUS_BAR ] 
  com.android.server.LocationManagerService.addGpsMeasurementsListener(android.location.IGpsMeasurementsListener,java.lang.String)boolean   ::  [ android.permission.ACCESS_FINE_LOCATION ] 
  com.android.server.LocationManagerService.addGpsNavigationMessageListener(android.location.IGpsNavigationMessageListener,java.lang.String)boolean   ::  [ android.permission.ACCESS_FINE_LOCATION ] 
  com.android.server.LocationManagerService.addGpsStatusListener(android.location.IGpsStatusListener,java.lang.String)boolean   ::  [ android.permission.ACCESS_FINE_LOCATION ] 
  com.android.server.LocationManagerService.getBestProvider(android.location.Criteria,boolean)java.lang.String   ::  [ android.permission.ACCESS_FINE_LOCATION ]  OR  [ android.permission.ACCESS_COARSE_LOCATION: ] 
  com.android.server.LocationManagerService.getLastLocation(android.location.LocationRequest,java.lang.String)android.location.Location   ::  [ android.permission.ACCESS_COARSE_LOCATION AND x1.getProvider()=$network$ AND mPackages.getPackagesForUid(Binder.getCallingUid())[]=x2 ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND !(x1.getProvider()=$network$) AND !(x1.getProvider()=$fused$) ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND x1.getProvider()=$gps$ AND mPackages.getPackagesForUid(Binder.getCallingUid())[]=x2 ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND x1.getProvider()=$passive$ AND mPackages.getPackagesForUid(Binder.getCallingUid())[]=x2 ]  OR  [ android.permission.ACCESS_COARSE_LOCATION AND x1.getProvider()=$fused$ AND mPackages.getPackagesForUid(Binder.getCallingUid())[]=x2 ] 
  com.android.server.LocationManagerService.getProviderProperties(java.lang.String)com.android.internal.location.ProviderProperties   ::  [ android.permission.ACCESS_COARSE_LOCATION AND x1.getProvider()=$network$ ]  OR  [ android.permission.ACCESS_COARSE_LOCATION AND x1.getProvider()=$fused$ ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND x1.getProvider()=$gps$ ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND !(x1.getProvider()=$network$) AND !(x1.getProvider()=$fused$) ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND x1.getProvider()=$passive$ ] 
  com.android.server.LocationManagerService.getProviders(android.location.Criteria,boolean)java.util.List   ::  [ android.permission.ACCESS_FINE_LOCATION ]  OR  [ android.permission.ACCESS_COARSE_LOCATION: ] 
  com.android.server.LocationManagerService.removeUpdates(android.location.ILocationListener,android.app.PendingIntent,java.lang.String)void   ::  [ android.permission.ACCESS_FINE_LOCATION ]  OR  [ android.permission.ACCESS_COARSE_LOCATION: ] 
  com.android.server.LocationManagerService.reportLocation(android.location.Location,boolean)void   ::  [ android.permission.INSTALL_LOCATION_PROVIDER AND android.permission.ACCESS_COARSE_LOCATION: ]  OR  [ android.permission.INSTALL_LOCATION_PROVIDER AND android.permission.ACCESS_FINE_LOCATION ]  OR  [ Binder.getCallingUid()=1000 AND android.permission.ACCESS_COARSE_LOCATION: ]  OR  [ Binder.getCallingUid=SYSTEM_UID AND android.permission.ACCESS_FINE_LOCATION ] 
  com.android.server.LocationManagerService.requestGeofence(android.location.LocationRequest,android.location.Geofence,android.app.PendingIntent,java.lang.String)void   ::  [ android.permission.ACCESS_FINE_LOCATION AND x1.getProvider()=$gps$ AND UserHandle.getUserId(Binder.getCallingUid())=0 ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND x1.getProvider()=$passive$ AND UserHandle.getUserId(Binder.getCallingUid())=0 ]  OR  [ android.permission.ACCESS_COARSE_LOCATION AND x1.getProvider()=$network$ AND UserHandle.getUserId(Binder.getCallingUid())=0 ]  OR  [ android.permission.ACCESS_COARSE_LOCATION AND x1.getProvider()=$fused$ AND UserHandle.getUserId(Binder.getCallingUid())=0 ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND !(x1.getProvider()=$network$) AND !(x1.getProvider()=$fused$) ] 
  com.android.server.LocationManagerService.requestLocationUpdates(android.location.LocationRequest,android.location.ILocationListener,android.app.PendingIntent,java.lang.String)void   ::  [ android.permission.ACCESS_FINE_LOCATION AND x1.getProvider()=$gps$ AND UserHandle.getUserId(Binder.getCallingUid())=0 ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND x1.getProvider()=$passive$ AND UserHandle.getUserId(Binder.getCallingUid())=0 ]  OR  [ android.permission.ACCESS_COARSE_LOCATION AND x1.getProvider()=$network$ AND UserHandle.getUserId(Binder.getCallingUid())=0 ]  OR  [ android.permission.ACCESS_COARSE_LOCATION AND x1.getProvider()=$fused$ AND UserHandle.getUserId(Binder.getCallingUid())=0 ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND !(x1.getProvider()=$network$) AND !(x1.getProvider()=$fused$) ] 
  com.android.server.LocationManagerService.sendExtraCommand(java.lang.String,java.lang.String,android.os.Bundle)boolean   ::  [ android.permission.ACCESS_COARSE_LOCATION AND x1.getProvider()=$fused$ AND android.permission.ACCESS_LOCATION_EXTRA_COMMANDS ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND x1.getProvider()=$gps$ AND android.permission.ACCESS_LOCATION_EXTRA_COMMANDS ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND x1.getProvider()=$passive$ AND android.permission.ACCESS_LOCATION_EXTRA_COMMANDS ]  OR  [ android.permission.ACCESS_FINE_LOCATION AND !(x1.getProvider()=$network$) AND !(x1.getProvider()=$fused$) ]  OR  [ android.permission.ACCESS_COARSE_LOCATION AND x1.getProvider()=$network$ AND android.permission.ACCESS_LOCATION_EXTRA_COMMANDS ] 
  com.android.server.LockSettingsService.checkPassword(java.lang.String,int)com.android.internal.widget.VerifyCredentialResponse   ::  [ android.permission.ACCESS_KEYGUARD_SECURE_STORAGE ] 
  com.android.server.LockSettingsService.checkPattern(java.lang.String,int)com.android.internal.widget.VerifyCredentialResponfse   ::  [ android.permission.ACCESS_KEYGUARD_SECURE_STORAGE ] 
  com.android.server.LockSettingsService.checkVoldPassword(int)boolean   ::  [ android.permission.ACCESS_KEYGUARD_SECURE_STORAGE ] 
  com.android.server.LockSettingsService.getLong(java.lang.String,long,int)long   ::  [ android.permission.READ_CONTACTS AND READ_CONTACTS_PROTECTED_SETTINGS[]=x1 ]  OR  [ android.permission.ACCESS_KEYGUARD_SECURE_STORAGE AND READ_PASSWORD_PROTECTED_SETTING[]=x1 ] 
  com.android.server.LockSettingsService.getString(java.lang.String,java.lang.String,int)java.lang.String   ::  [ android.permission.READ_CONTACTS AND READ_CONTACTS_PROTECTED_SETTINGS[]=x1 ]  OR  [ android.permission.ACCESS_KEYGUARD_SECURE_STORAGE AND READ_PASSWORD_PROTECTED_SETTING[]=x1 ] 
  com.android.server.LockSettingsService.registerStrongAuthTracker(android.app.trust.IStrongAuthTracker)void   ::  [ android.permission.ACCESS_KEYGUARD_SECURE_STORAGE ] 
  com.android.server.LockSettingsService.requireStrongAuth(int,int)void   ::  [ android.permission.ACCESS_KEYGUARD_SECURE_STORAGE ] 
  com.android.server.LockSettingsService.setBoolean(java.lang.String,boolean,int)void   ::  [ android.permission.ACCESS_KEYGUARD_SECURE_STORAGE ] 
  com.android.server.LockSettingsService.setLockPassword(java.lang.String,java.lang.String,int)void   ::  [ android.permission.ACCESS_KEYGUARD_SECURE_STORAGE ] 
  com.android.server.LockSettingsService.setLockPattern(java.lang.String,java.lang.String,int)void   ::  [ android.permission.ACCESS_KEYGUARD_SECURE_STORAGE ] 
  com.android.server.LockSettingsService.setLong(java.lang.String,long,int)void   ::  [ android.permission.ACCESS_KEYGUARD_SECURE_STORAGE ] 
  com.android.server.LockSettingsService.setString(java.lang.String,java.lang.String,int)void   ::  [ android.permission.ACCESS_KEYGUARD_SECURE_STORAGE ] 
  com.android.server.LockSettingsService.unregisterStrongAuthTracker(android.app.trust.IStrongAuthTracker)void   ::  [ android.permission.ACCESS_KEYGUARD_SECURE_STORAGE ] 
  com.android.server.LockSettingsService.verifyPassword(java.lang.String,long,int)com.android.internal.widget.VerifyCredentialResponse   ::  [ android.permission.ACCESS_KEYGUARD_SECURE_STORAGE ] 
  com.android.server.LockSettingsService.verifyPattern(java.lang.String,long,int)com.android.internal.widget.VerifyCredentialResponse   ::  [ android.permission.ACCESS_KEYGUARD_SECURE_STORAGE ] 
  com.android.server.MountService.benchmark(java.lang.String)long   ::  [ android.permission.MOUNT_FORMAT_FILESYSTEMS ] 
  com.android.server.MountService.changeEncryptionPassword(int,java.lang.String)int   ::  [ android.permission.CRYPT_KEEPER ] 
  com.android.server.MountService.createSecureContainer(java.lang.String,int,java.lang.String,java.lang.String,int,boolean)int   ::  [ android.permission.ASEC_CREATE ] 
  com.android.server.MountService.decryptStorage(java.lang.String)int   ::  [ android.permission.CRYPT_KEEPER ] 
  com.android.server.MountService.destroySecureContainer(java.lang.String,boolean)int   ::  [ android.permission.ASEC_DESTROY ] 
  com.android.server.MountService.encryptStorage(int,java.lang.String)int   ::  [ android.permission.CRYPT_KEEPER ] 
  com.android.server.MountService.finalizeSecureContainer(java.lang.String)int   ::  [ android.permission.ASEC_CREATE ] 
  com.android.server.MountService.fixPermissionsSecureContainer(java.lang.String,int,java.lang.String)int   ::  [ android.permission.ASEC_CREATE ] 
  com.android.server.MountService.forgetAllVolumes()void   ::  [ android.permission.MOUNT_UNMOUNT_FILESYSTEMS ] 
  com.android.server.MountService.forgetVolume(java.lang.String)void   ::  [ android.permission.MOUNT_UNMOUNT_FILESYSTEMS ] 
  com.android.server.MountService.format(java.lang.String)void   ::  [ android.permission.MOUNT_FORMAT_FILESYSTEMS ] 
  com.android.server.MountService.formatVolume(java.lang.String)int   ::  [ android.permission.MOUNT_FORMAT_FILESYSTEMS ] 
  com.android.server.MountService.getEncryptionState()int   ::  [ android.permission.CRYPT_KEEPER ] 
  com.android.server.MountService.getPassword()java.lang.String   ::  [ android.permission.ACCESS_KEYGUARD_SECURE_STORAGE ] 
  com.android.server.MountService.getPrimaryStorageUuid()java.lang.String   ::  [ android.permission.MOUNT_UNMOUNT_FILESYSTEMS ] 
  com.android.server.MountService.getSecureContainerFilesystemPath(java.lang.String)java.lang.String   ::  [ android.permission.ASEC_ACCESS ] 
  com.android.server.MountService.getSecureContainerList()java.lang.String[]   ::  [ android.permission.ASEC_ACCESS ] 
  com.android.server.MountService.getSecureContainerPath(java.lang.String)java.lang.String   ::  [ android.permission.ASEC_ACCESS ] 
  com.android.server.MountService.getStorageUsers(java.lang.String)I[]   ::  [ android.permission.MOUNT_UNMOUNT_FILESYSTEMS ] 
  com.android.server.MountService.isSecureContainerMounted(java.lang.String)boolean   ::  [ android.permission.ASEC_ACCESS ] 
  com.android.server.MountService.mount(java.lang.String)void   ::  [ android.permission.MOUNT_UNMOUNT_FILESYSTEMS ] 
  com.android.server.MountService.mountSecureContainer(java.lang.String,java.lang.String,int,boolean)int   ::  [ android.permission.ASEC_MOUNT_UNMOUNT ] 
  com.android.server.MountService.mountVolume(java.lang.String)int   ::  [ android.permission.MOUNT_UNMOUNT_FILESYSTEMS ] 
  com.android.server.MountService.partitionMixed(java.lang.String,int)void   ::  [ android.permission.MOUNT_FORMAT_FILESYSTEMS ]  OR  [ UserManager.getUserInfo(UserHandle.getCallingUserId()).isAdmin ] 
  com.android.server.MountService.partitionPrivate(java.lang.String)void   ::  [ android.permission.MOUNT_FORMAT_FILESYSTEMS ]  OR  [ UserManager.getUserInfo(UserHandle.getCallingUserId()).isAdmin ] 
  com.android.server.MountService.partitionPublic(java.lang.String)void   ::  [ android.permission.MOUNT_FORMAT_FILESYSTEMS ] 
  com.android.server.MountService.renameSecureContainer(java.lang.String,java.lang.String)int   ::  [ android.permission.ASEC_RENAME ] 
  com.android.server.MountService.resizeSecureContainer(java.lang.String,int,java.lang.String)int   ::  [ android.permission.ASEC_CREATE ] 
  com.android.server.MountService.runMaintenance()void   ::  [ android.permission.MOUNT_UNMOUNT_FILESYSTEMS ] 
  com.android.server.MountService.setDebugFlags(int,int)void   ::  [ android.permission.MOUNT_UNMOUNT_FILESYSTEMS ] 
  com.android.server.MountService.setPrimaryStorageUuid(java.lang.String,android.content.pm.IPackageMoveObserver)void   ::  [ android.permission.MOUNT_UNMOUNT_FILESYSTEMS ] 
  com.android.server.MountService.setVolumeNickname(java.lang.String,java.lang.String)void   ::  [ android.permission.MOUNT_UNMOUNT_FILESYSTEMS ] 
  com.android.server.MountService.setVolumeUserFlags(java.lang.String,int,int)void   ::  [ android.permission.MOUNT_UNMOUNT_FILESYSTEMS ] 
  com.android.server.MountService.shutdown(boolean,boolean)void   ::  [ android.permission.SHUTDOWN ] 
  com.android.server.MountService.unmount(java.lang.String)void   ::  [ android.permission.MOUNT_UNMOUNT_FILESYSTEMS ] 
  com.android.server.MountService.unmountSecureContainer(java.lang.String,boolean)int   ::  [ android.permission.ASEC_MOUNT_UNMOUNT ] 
  com.android.server.MountService.unmountVolume(java.lang.String,boolean,boolean)void   ::  [ android.permission.MOUNT_UNMOUNT_FILESYSTEMS ] 
  com.android.server.MountService.verifyEncryptionPassword(java.lang.String)int   ::  [ Binder.getCallingUID==SYSTEM_UID AND android.permission.CRYPT_KEEPER ] 
  com.android.server.NetworkManagementService.addIdleTimer(java.lang.String,int,int)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.addInterfaceToLocalNetwork(java.lang.String,java.util.List)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.addInterfaceToNetwork(java.lang.String,int)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.addLegacyRouteForNetId(int,android.net.RouteInfo,int)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.addRoute(int,android.net.RouteInfo)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.addVpnUidRanges(int,[android.net.UidRange)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.allowProtect(int)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.attachPppd(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.clearDefaultNetId()void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.clearInterfaceAddresses(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.clearPermission([int)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.createPhysicalNetwork(int,java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.createVirtualNetwork(int,boolean,boolean)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.denyProtect(int)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.detachPppd(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.disableIpv6(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.disableNat(java.lang.String,java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.enableIpv6(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.enableNat(java.lang.String,java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.flushNetworkDnsCache(int)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.getDnsForwarders()java.lang.String[]   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.getInterfaceConfig(java.lang.String)android.net.InterfaceConfiguration   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.getIpForwardingEnabled()boolean   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.getNetworkStatsDetail()android.net.NetworkStats   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.getNetworkStatsSummaryDev()android.net.NetworkStats   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.getNetworkStatsSummaryXt()android.net.NetworkStats   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.getNetworkStatsTethering()android.net.NetworkStats   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.getNetworkStatsUidDetail(int)android.net.NetworkStats   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.isBandwidthControlEnabled()boolean   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.isClatdStarted(java.lang.String)boolean   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.isTetheringStarted()boolean   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.listInterfaces()java.lang.String[]   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.listTetheredInterfaces()java.lang.String[]   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.listTtys()java.lang.String[]   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.registerObserver(android.net.INetworkManagementEventObserver)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.removeIdleTimer(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.removeInterfaceAlert(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.removeInterfaceFromLocalNetwork(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.removeInterfaceFromNetwork(java.lang.String,int)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.removeInterfaceQuota(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.removeNetwork(int)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.removeRoute(int,android.net.RouteInfo)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.removeVpnUidRanges(int,[android.net.UidRange)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setAccessPoint(android.net.wifi.WifiConfiguration,java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setDefaultNetId(int)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setDnsForwarders(android.net.Network,[java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setDnsServersForNetwork(int,[java.lang.String,java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setGlobalAlert(long)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setInterfaceAlert(java.lang.String,long)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setInterfaceConfig(java.lang.String,android.net.InterfaceConfiguration)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setInterfaceDown(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setInterfaceIpv6NdOffload(java.lang.String,boolean)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setInterfaceIpv6PrivacyExtensions(java.lang.String,boolean)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setInterfaceQuota(java.lang.String,long)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setInterfaceUp(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setIpForwardingEnabled(boolean)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setMtu(java.lang.String,int)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setNetworkPermission(int,java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setPermission(java.lang.String,[int)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setUidCleartextNetworkPolicy(int,int)void   ::  [ Binder.getCallingUid()=x1 ]  OR  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.setUidNetworkRules(int,boolean)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.shutdown(boolean,boolean)void   ::  [ android.permission.SHUTDOWN ] 
  com.android.server.NetworkManagementService.startAccessPoint(android.net.wifi.WifiConfiguration,java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.startClatd(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.startInterfaceForwarding(java.lang.String,java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.startTethering([java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.stopAccessPoint(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.stopClatd(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.stopInterfaceForwarding(java.lang.String,java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.stopTethering()void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.tetherInterface(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.unregisterObserver(android.net.INetworkManagementEventObserver)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.untetherInterface(java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkManagementService.wifiFirmwareReload(java.lang.String,java.lang.String)void   ::  [ android.permission.CONNECTIVITY_INTERNAL ] 
  com.android.server.NetworkScoreService.clearScores()boolean   ::  [ android.permission.SCORE_NETWORKS ]  OR  [ android.permission.BROADCAST_NETWORK_PRIVILEGED: ] 
  com.android.server.NetworkScoreService.disableScoring()void   ::  [ android.permission.SCORE_NETWORKS ]  OR  [ android.permission.BROADCAST_NETWORK_PRIVILEGED: ] 
  com.android.server.NetworkScoreService.registerNetworkScoreCache(int,android.net.INetworkScoreCache)void   ::  [ android.permission.BROADCAST_NETWORK_PRIVILEGED ] 
  com.android.server.NetworkScoreService.setActiveScorer(java.lang.String)boolean   ::  [ android.permission.SCORE_NETWORKS ] 
  com.android.server.NetworkScoreService.updateScores([android.net.ScoredNetwork)boolean   ::  [ android.permission.SCORE_NETWORKS ] 
  com.android.server.NsdService.getMessenger()android.os.Messenger   ::  [ android.permission.INTERNET ] 
  com.android.server.SerialService.getSerialPorts()java.lang.String[]   ::  [ android.permission.SERIAL_PORT ] 
  com.android.server.SerialService.openSerialPort(java.lang.String)android.os.ParcelFileDescriptor   ::  [ android.permission.SERIAL_PORT ] 
  com.android.server.TelephonyRegistry.notifyCallForwardingChanged(boolean)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyCallForwardingChangedForSubscriber(int,boolean)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyCallState(int,java.lang.String)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyCallStateForSubscriber(int,int,java.lang.String)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyCarrierNetworkChange(boolean)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyCellInfo(java.util.List)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyCellInfoForSubscriber(int,java.util.List)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyCellLocation(android.os.Bundle)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyCellLocationForSubscriber(int,android.os.Bundle)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyDataActivity(int)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyDataActivityForSubscriber(int,int)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyDataConnection(int,boolean,java.lang.String,java.lang.String,java.lang.String,android.net.LinkProperties,android.net.NetworkCapabilities,int,boolean)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyDataConnectionFailed(java.lang.String,java.lang.String)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyDataConnectionFailedForSubscriber(int,java.lang.String,java.lang.String)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyDataConnectionForSubscriber(int,int,boolean,java.lang.String,java.lang.String,java.lang.String,android.net.LinkProperties,android.net.NetworkCapabilities,int,boolean)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyDataConnectionRealTimeInfo(android.telephony.DataConnectionRealTimeInfo)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyDisconnectCause(int,int)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyMessageWaitingChangedForPhoneId(int,int,boolean)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyOemHookRawEventForSubscriber(int,[byte)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyOtaspChanged(int)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyPreciseCallState(int,int,int)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyPreciseDataConnectionFailed(java.lang.String,java.lang.String,java.lang.String,java.lang.String)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyServiceStateForPhoneId(int,int,android.telephony.ServiceState)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifySignalStrength(android.telephony.SignalStrength)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifySignalStrengthForSubscriber(int,android.telephony.SignalStrength)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TelephonyRegistry.notifyVoLteServiceStateChanged(android.telephony.VoLteServiceState)void   ::  [ android.permission.MODIFY_PHONE_STATE ] 
  com.android.server.TextServicesManagerService.setCurrentSpellCheckerSubtype(java.lang.String,int)void   ::  [ android.permission.WRITE_SECURE_SETTINGS AND Binder.getCallingUid()=1000 ]  OR  [ android.permission.WRITE_SECURE_SETTINGS AND UserHandle.getCallingUserId()=ActivityManager.getCurrentUser() ] 
  com.android.server.TextServicesManagerService.setSpellCheckerEnabled(boolean)void   ::  [ android.permission.WRITE_SECURE_SETTINGS AND Binder.getCallingUid()=1000 ]  OR  [ android.permission.WRITE_SECURE_SETTINGS AND UserHandle.getCallingUserId()=ActivityManager.getCurrentUser() ] 
  com.android.server.UpdateLockService.acquireUpdateLock(android.os.IBinder,java.lang.String)void   ::  [ android.permission.UPDATE_LOCK ] 
  com.android.server.UpdateLockService.releaseUpdateLock(android.os.IBinder)void   ::  [ android.permission.UPDATE_LOCK ] 
  com.android.server.VibratorService.cancelVibrate(android.os.IBinder)void   ::  [ android.permission.VIBRATE ] 
  com.android.server.VibratorService.vibrate(int,java.lang.String,long,int,android.os.IBinder)void   ::  [ android.permission.VIBRATE AND Binder.getCallingUid()=x1 ]  OR  [ android.permission.VIBRATE AND android.permission.UPDATE_APP_OPS_STATS ]  OR  [ android.permission.VIBRATE AND Binder.getCallingPid()=Process.myPid() ] 
  com.android.server.VibratorService.vibratePattern(int,java.lang.String,[long,int,int,android.os.IBinder)void   ::  [ android.permission.VIBRATE AND Binder.getCallingUid()=x1 ]  OR  [ android.permission.VIBRATE AND android.permission.UPDATE_APP_OPS_STATS ]  OR  [ android.permission.VIBRATE AND Binder.getCallingPid()=Process.myPid() ] 
  com.android.server.accounts.AccountManagerService.addAccountAsUser(android.accounts.IAccountManagerResponse,java.lang.String,java.lang.String,[java.lang.String,boolean,android.os.Bundle,int)void   ::  [ Binder.getCallingUid()=Process.myUid() ]  OR  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ UserHandle.getCallingUserId()=x7 ] 
  com.android.server.accounts.AccountManagerService.confirmCredentialsAsUser(android.accounts.IAccountManagerResponse,android.accounts.Account,android.os.Bundle,boolean,int)void   ::  [ Binder.getCallingUid()=Process.myUid() ]  OR  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ UserHandle.getCallingUserId()=x5 ] 
  com.android.server.accounts.AccountManagerService.copyAccountToUser(android.accounts.IAccountManagerResponse,android.accounts.Account,int,int)void   ::  [ Binder.getCallingUid()=Process.myUid() ]  OR  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ UserHandle.getCallingUserId()=-1 ] 
  com.android.server.accounts.AccountManagerService.getAccounts(java.lang.String,java.lang.String)android.accounts.Account[]   ::  [ android.permission.GET_ACCOUNTS_PRIVILEGED ] 
  com.android.server.accounts.AccountManagerService.getAccountsAsUser(java.lang.String,int,java.lang.String)android.accounts.Account[]   ::  [ UserHandle.isSameApp(Binder.getCallingUid():Process.myUid()) AND UserHandle.getCallingUserId()=x2 AND android.permission.GET_ACCOUNTS_PRIVILEGED ]  OR  [ UserHandle.isSameApp(Binder.getCallingUid():Process.myUid()) AND android.permission.INTERACT_ACROSS_USERS_FULL AND android.permission.GET_ACCOUNTS_PRIVILEGED ]  OR  [ UserHandle.isSameApp(Binder.getCallingUid():Process.myUid()) AND Binder.getCallingUid()=Process.myUid() AND android.permission.GET_ACCOUNTS_PRIVILEGED ] 
  com.android.server.accounts.AccountManagerService.getAccountsByTypeForPackage(java.lang.String,java.lang.String,java.lang.String)android.accounts.Account[]   ::  [ UserHandle.isSameApp(Binder.getCallingUid():Process.myUid()) AND android.permission.GET_ACCOUNTS_PRIVILEGED ] 
  com.android.server.accounts.AccountManagerService.getAuthenticatorTypes(int)android.accounts.AuthenticatorDescription[]   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ UserHandle.getCallingUserId()=x1 ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.accounts.AccountManagerService.removeAccountAsUser(android.accounts.IAccountManagerResponse,android.accounts.Account,boolean,int)void   ::  [ android.permission.INTERACT_ACROSS_USERS_FULL ]  OR  [ UserHandle.getCallingUserId()=x4 ]  OR  [ Binder.getCallingUid()=1000 ] 
  com.android.server.am.ActivityManagerService.appNotRespondingViaProvider(android.os.IBinder)void   ::  [ android.permission.REMOVE_TASKS ] 
  com.android.server.am.ActivityManagerService.bindBackupAgent(android.content.pm.ApplicationInfo,int)boolean   ::  [ android.permission.CONFIRM_FULL_BACKUP ] 
  com.android.server.am.ActivityManagerService.bootAnimationComplete()void   ::  [ android.permission.BROADCAST_STICKY ] 
  com.android.server.am.ActivityManagerService.clearPendingBackup()void   ::  [ android.permission.BACKUP ] 
  com.android.server.am.ActivityManagerService.crashApplication(int,int,java.lang.String,java.lang.String)void   ::  [ android.permission.FORCE_STOP_PACKAGES ] 
  com.android.server.am.ActivityManagerService.createStackOnDisplay(int)android.app.IActivityContainer   ::  [ android.permission.MANAGE_ACTIVITY_STACKS ] 
  com.android.server.am.ActivityManagerService.createVirtualActivityContainer(android.os.IBinder,android.app.IActivityContainerCallback)android.app.IActivityContainer   ::  [ android.permission.MANAGE_ACTIVITY_STACKS ] 
  com.android.server.am.ActivityManagerService.deleteActivityContainer(android.app.IActivityContainer)void   ::  [ android.permission.MANAGE_ACTIVITY_STACKS ] 
  com.android.server.am.ActivityManagerService.dumpHeap(java.lang.String,int,boolean,java.lang.String,android.os.ParcelFileDescriptor)boolean   ::  [ android.permission.SET_ACTIVITY_WATCHER ] 
  com.android.server.am.ActivityManagerService.finishHeavyWeightApp()void   ::  [ android.permission.FORCE_STOP_PACKAGES ] 
  com.android.server.am.ActivityManagerService.forceStopPackage(java.lang.String,int)void   ::  [ android.permission.FORCE_STOP_PACKAGES AND otherconditionsaresatisfied ] 
  com.android.server.am.ActivityManagerService.getAllStackInfos()java.util.List   ::  [ android.permission.MANAGE_ACTIVITY_STACKS ] 
  com.android.server.am.ActivityManagerService.getAssistContextExtras(int)android.os.Bundle   ::  [ android.permission.GET_TOP_ACTIVITY_INFO ] 